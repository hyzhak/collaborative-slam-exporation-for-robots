# Request-Reply Event Naming

## Purpose

Document the canonical event naming scheme used by the request-reply handlers and orchestrators so that new steps can be registered without guessing stream, group, or `event_type` values.

## Naming Conventions

- **Command streams** follow the `domain:commands` pattern (e.g., `resources:commands`, `routing:commands`). Each handler module exposes its stream name via a `STREAM_NAME` constant that matches this format.【F:app/commands/handlers/allocate_resources.py†L7-L21】【F:app/commands/handlers/plan_route.py†L6-L18】
- **Reply streams** reuse the same domain prefix with a `:replies` suffix and append the per-request UUID generated by `request_and_reply` (e.g., `resources:replies:<request_id>`).【F:app/redis_utils/replies.py†L146-L165】
- **Event types** are lowercase strings with a colon between domain and action (e.g., `resources:allocate`, `mission:start`). Each handler defines its `EVENT_TYPE` constant using this pattern.【F:app/commands/handlers/start_mission.py†L7-L35】【F:app/commands/handlers/integrate_maps.py†L6-L19】
- **Statuses** emitted on reply streams are one of `start`, `progress`, `completed`, or `failed`, as enforced by the `multi_stage_reply` decorator applied to every command handler.【F:app/redis_utils/decorators.py†L8-L76】

## Handler Registry

| Handler Module        | Command Stream        | Consumer Group               | Event Type            |
| --------------------- | --------------------- | ---------------------------- | --------------------- |
| start_mission         | `mission:commands`    | `mission_orchestrator_group` | `mission:start`       |
| allocate_resources    | `resources:commands`  | `resources_allocator_group`  | `resources:allocate`  |
| plan_route            | `routing:commands`    | `routing_handler_group`      | `routing:plan`        |
| perform_exploration   | `exploration:commands`| `exploration_handler_group`  | `exploration:perform` |
| integrate_maps        | `map:commands`        | `map_handler_group`          | `map:integrate`       |
| release_resources     | `resources:commands`  | `resources_release_group`    | `resources:release`   |

_Source: handler constants discovered by `app/commands/listener.py`._【F:app/commands/listener.py†L16-L74】【F:app/commands/handlers/release_resources.py†L7-L21】

## Orchestrator Usage

Both saga orchestrators issue commands using the same event type strings so that handlers receive messages they are registered to process. For example, the Celery mission saga publishes `resources:allocate`, `routing:plan`, `exploration:perform`, and `map:integrate` commands using the helper `request_and_reply`, which then waits on the matching reply stream.【F:app/flows/mission_start_celery/tasks.py†L8-L78】

The async orchestrator follows the same pattern for the primary steps but currently emits its final release step on `release_resources` with `event_type="release_resources"`, which does **not** match the handler’s `resources:commands` / `resources:release` naming convention. Aligning this step with the table above will keep the workflow consistent with the documented scheme.【F:app/flows/mission_start_async/orchestrator.py†L111-L123】【F:app/commands/handlers/release_resources.py†L7-L21】

## Implementation Notes

- When adding a new handler, expose `STREAM_NAME`, `GROUP_NAME`, and `EVENT_TYPE` constants so the listener can auto-register it.【F:app/commands/listener.py†L16-L74】
- Always include the originating `event_type` in emitted events; the decorator reuses the incoming value so downstream consumers can correlate replies with requests.【F:app/redis_utils/decorators.py†L18-L66】
- The reply reader acknowledges and filters events by `status`, so ensure handlers progress through the documented sequence to unblock waiting orchestration steps.【F:app/redis_utils/replies.py†L90-L129】
